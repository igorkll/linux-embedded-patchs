diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 57eac02ea..faa7b3cb8 100755
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -2321,52 +2321,7 @@ asmlinkage int vprintk_emit(int facility, int level,
 			    const struct dev_printk_info *dev_info,
 			    const char *fmt, va_list args)
 {
-	int printed_len;
-	bool in_sched = false;
-
-	/* Suppress unimportant messages after panic happens */
-	if (unlikely(suppress_printk))
-		return 0;
-
-	if (unlikely(suppress_panic_printk) && other_cpu_in_panic())
-		return 0;
-
-	if (level == LOGLEVEL_SCHED) {
-		level = LOGLEVEL_DEFAULT;
-		in_sched = true;
-	}
-
-	printk_delay(level);
-
-	printed_len = vprintk_store(facility, level, dev_info, fmt, args);
-
-	/* If called from the scheduler, we can not call up(). */
-	if (!in_sched) {
-		/*
-		 * The caller may be holding system-critical or
-		 * timing-sensitive locks. Disable preemption during
-		 * printing of all remaining records to all consoles so that
-		 * this context can return as soon as possible. Hopefully
-		 * another printk() caller will take over the printing.
-		 */
-		preempt_disable();
-		/*
-		 * Try to acquire and then immediately release the console
-		 * semaphore. The release will print out buffers. With the
-		 * spinning variant, this context tries to take over the
-		 * printing from another printing context.
-		 */
-		if (console_trylock_spinning())
-			console_unlock();
-		preempt_enable();
-	}
-
-	if (in_sched)
-		defer_console_output();
-	else
-		wake_up_klogd();
-
-	return printed_len;
+	return 0;
 }
 EXPORT_SYMBOL(vprintk_emit);
 
